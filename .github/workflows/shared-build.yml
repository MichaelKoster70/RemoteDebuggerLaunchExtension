name: Build

on:
  workflow_call:
    inputs:
      store-artifacts:
        description: 'Flag if artifacts sould be stored'
        type: boolean
        required: true
        default: false
      configuration:
        description: 'The Visual Studio Configuration to build'
        type: string
        required: false
        default: 'Release'
      solution-path:
        description: 'The path to the VS solution to build'
        type: string
        required: false
        default: 'RemoteDebuggerLauncherExtension.sln'


jobs:
  shared_build:
    name: Build VS Extension
    runs-on: windows-2022

    env:
      ExtensionAssemblyInfoFile: ${{ github.workspace }}\src\Extension\GlobalAssemblyInfo.cs
      ExtensionManifestFile: ${{ github.workspace }}\src\Extension\RemoteDebuggerLauncher\source.extension.vsixmanifest
      ExtensionOutputPath: ${{ github.workspace }}\src\Extension\RemoteDebuggerLauncher\bin\${{ inputs.configuration }}
      ScriptPath: ${{ github.workspace }}\eng\scripts

    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    # setup MSBUILD and VS
    - name: Add MSBUILD to PATH
      id: msbuild
      uses: microsoft/setup-msbuild@v1.1
      with:
        vs-version: '[17.2,17.5)'
        msbuild-architecture: x64

    # Build Solution: determine and apply the version for the assemblies and VSIX package
    - name: 'Build Solution: Determine Version'
      id: git-version
      uses: ./eng/actions/git-version

      # apply dev versions on pushes to any other branches
    - name: 'Build Solution: Apply assembly version DEV'
      if: ${{ github.ref_type == 'branch' && github.ref != 'refs/heads/main' }}
      run:  ${{ env.ScriptPath }}\AssemblyInfoFileSetVersion.ps1 -SourceFilePath  ${{ env.ExtensionAssemblyInfoFile }}
        -VersionPrefix ${{ steps.git-version.outputs.versionPrefix }}
        -VersionSuffix ${{ steps.git-version.outputs.versionSuffix }}
        -VersionBuild ${{ steps.git-version.outputs.versionBuild }}
      shell: pwsh

      # apply prod versions on pushes to the main branch or a tag gets created
    - name: 'Build Solution: Apply assembly version PROD'
      if: ${{ (github.ref_type == 'branch' && github.ref == 'refs/heads/main') || github.ref_type == 'tag' }}
      run:  ${{ env.ScriptPath }}\AssemblyInfoFileSetVersion.ps1 -SourceFilePath  ${{ env.ExtensionAssemblyInfoFile }}
        -VersionPrefix ${{ steps.git-version.outputs.versionPrefix }}
        -VersionBuild ${{ steps.git-version.outputs.versionBuild }}
      shell: pwsh

    - name: 'Build Solution: Apply VSIX version'
      run:  ${{ env.ScriptPath }}\VsixManifestFileSetVersion.ps1 -SourceFilePath  ${{ env.ExtensionManifestFile }} -VersionPrefix ${{ steps.git-version.outputs.versionPrefix }}
      shell: pwsh

    # Build Solution: restore NuGet Packages
    - name: 'Build Solution: NuGet restore'
      id: nuget-restore
      run: msbuild ${{ inputs.solution-path }} /t:Restore /p:Configuration=${{ inputs.configuration }}
      shell: pwsh

    # Build Solution: Rebuild
    - name: 'Build Solution: Rebuild'
      id: build
      run: msbuild ${{ inputs.solution-path }} /t:Rebuild /p:Configuration=${{ inputs.configuration }}
      shell: pwsh

    - name: 'Store Artifacts: VSIX'
      uses: actions/upload-artifact@v3
      if: ${{ inputs.store-artifacts }}
      with:
        name: vsix
        path: ${{ env.ExtensionOutputPath }}\*.vsix

    - name: 'Store Artifacts: Binaries'
      uses: actions/upload-artifact@v3
      if: ${{ inputs.store-artifacts }}
      with:
        name: binaries
        path: |
          ${{ env.ExtensionOutputPath }}
          !${{ env.ExtensionOutputPath }}\*.vsix
